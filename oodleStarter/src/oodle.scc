Package com.bju.cps450;

Helpers

  tab = 9;
  line_feed = 10;
  carriage_return = 13;
  eol_chars = [10 + 13];
  end_of_line = eol_chars | 13 10 ; 
  
  sign = '+' | '-';
  
  letter = [['a'..'z'] + ['A'..'Z']];
  octal = ['0'..'7'];
  digit = ['0'..'9'];
  number = digit+;
  ascii_chars = [0..0xff] ;
  all_chars = [0..0xffff] ;
  str_start = '"' ;
  
States
  normal, in_comment, in_string ;

Tokens
  ignored_newline = '_' end_of_line ;
  {normal} newline = end_of_line ;
  blank = ' ' | tab ;
 
//*****keywords**********
  boolean = 'boolean' ;
  begin = 'begin' ;
  class_key = 'class' ;
  else = 'else' ;
  end = 'end' ;
  false = 'false' ;
  from = 'from' ;
  if = 'if' ;
  inherits = 'inherits' ;
  int = 'int' ;
  is = 'is' ;
  loop = 'loop' ;
  me = 'me' ;
  new = 'new' ;
  null = 'null' ;
  string = 'string' ;
  then = 'then' ;
  true = 'true' ;
  while = 'while' ;

  //******operator keywords****************
  and = 'and' ;
  or = 'or' ;
  not = 'not' ;

  int_literal = sign? number ;

// *****strings*******
  {normal -> in_string} str_start = '"' ;
  {in_string -> normal} str_iteral = (('\' octal octal octal) | ('\'  ('t' | 'n' | 'f' | 'r' | '"' | '\')) | [[[ascii_chars - eol_chars ]- '\' ] - '"'])* '"' ;
  {in_string -> normal} unterminated_str = (('\' octal octal octal) | ('\'  ('t' | 'n' | 'f' | 'r' | '"' | '\')) | [[[ascii_chars - eol_chars ]- '\' ] - '"'])* end_of_line ;
  {in_string -> normal} illegal_str = (('\' octal octal octal) | ('\'  ('t' | 'n' | 'f' | 'r' | '"' | '\')) | [[ascii_chars - eol_chars ] - '"'])* '"' ;

  // ********operators*************
  strconcat = '&' ;
  addition = '+' ;
  subtraction = '-' ;
  multiplication = '*';
  division = '/' ;
  equal = '=';
  greater_than = '>';
  greater_eq = '>=';
  assignment = ':=' ;
  lparen = '(' ;
  rparen = ')' ;
  lbrace = '[' ;
  rbrace = ']' ;
  comma = ',' ;
  semicolon = ';' ;
  colon = ':' ;
  dot = '.' ;

  identifier = (letter | '_') (letter | digit | '_')* ;
  invalid_identifier = sign? digit (letter | digit | '_')* ;


// **********comments***************
  comment = '~' [all_chars - eol_chars]* ;
  unknown = all_chars ;

Ignored Tokens
    blank, ignored_newline, comment;

Productions
    //start production: <start> :=	[ <cr> ] <class> { <cr> <class> } [ <cr> ]
  start = [left]:T.newline* [init]:class inner_class* [right]:T.newline*;

  class = T.class_key [left]:T.identifier inherits_from? T.is T.newline+ var_decl* method_decl* T.end [right]:T.identifier;

  var_decl = T.identifier var_type? var_exp? T.newline+;

  method_decl = method_header method_middle method_end;

  argument_decl_list = arg_list_helper* argument_decl;

  argument_decl = T.identifier T.colon type;

  type = {int}       T.int
       | {string}    T.string
       | {boolean}   T.boolean
       | {id}        T.identifier
       | {array}     T.lbrace expression? T.rbrace;

  statement_list = statement_list_helper*;

  statement = {asgn} assignment_stmt
        |{if}   if_stmt
        |{loop}   loop_stmt
        |{call}   call_stmt;

  assignment_stmt = T.identifier expression_helper* T.assignment expression;

  if_stmt = [left]:T.if expression T.then T.newline+ statement_list if_else? T.end [right]:T.if;

  loop_stmt = [left]:T.loop T.while expression T.newline+ statement_list T.end [right]:T.loop;

  call_stmt = call_helper? T.identifier T.lparen expression_list? T.rparen;

  expression_list = expression_list_helper* expression;

  expression = expression_lvl6;

  expression_lvl6 = {or}   expression_lvl6 T.or expression_lvl5
                    | {pass} expression_lvl5;

  expression_lvl5 = {and}  expression_lvl5 T.and expression_lvl4
                    | {pass} expression_lvl4;

  expression_lvl4 = {eq}   [left]:expression_lvlc T.equal [right]:expression_lvlc
                    | {gt}    [left]:expression_lvlc T.greater_eq [right]:expression_lvlc
                    | {gte}   [left]:expression_lvlc T.greater_than [right]:expression_lvlc
                    | {pass} expression_lvlc;

  expression_lvlc = {concat}  expression_lvlc T.strconcat expression_lvl3
                  |{pass}   expression_lvl3;

  expression_lvl3 = {add}   expression_lvl3 T.addition expression_lvl2
                  | {sub}   expression_lvl3 T.subtraction expression_lvl2
                  | {pass}  expression_lvl2;

  expression_lvl2 = {mul}   expression_lvl2 T.multiplication expression_lvl1
                  | {div}   expression_lvl2 T.division expression_lvl1
                  | {pass}  expression_lvl1;

  expression_lvl1 = {not}   T.not expression_lvl1
                  | {add}   T.addition expression_lvl1
                  | {neg}   T.subtraction expression_lvl1
                  | {pass}  expression_lvl0;

  expression_lvl0 = {identifier}  T.identifier
                  | {string}      T.str_start T.str_iteral
                  | {int}         T.int_literal
                  | {true}        T.true
                  | {false}       T.false
                  | {new_obj}     T.new type
                  | {me}          T.me
                  | {expr}        T.lparen expression T.rparen
                  | {mcall}       call_helper? T.identifier T.lparen expression_list? T.rparen
                  | {array}       T.identifier expression_helper+;



  //helpers
  //method header: "id ( [ <argument_decl_list> ] ) [ : <type> ] is <cr> { <var_decl> }"
  method_header = T.identifier T.lparen argument_decl_list? T.rparen var_type? T.is T.newline+ var_decl* ;

  //method middle: "begin <cr> <statement_list>"
  method_middle = T.begin T.newline+ statement_list;

  //method end: "end id <cr>"
  method_end = T.end T.identifier T.newline+;

  //beginning of expression list: "{ <expression> , }"
  expression_list_helper = expression T.comma;

  //expression call helper: "[ <expression> ]"
  expression_helper = T.lbrace expression T.rbrace;

  //expression dot: "<expression> ."
  call_helper = expression_lvl0 T.dot;

  //if /else/ helper: "else <cr> <statement_list>"
  if_else = T.else T.newline+ statement_list;

  //statement list helper: "<statement> <cr>"
  statement_list_helper = statement T.newline+;

  //type declaration: ": <type>"
  var_type = T.colon type;

  //var assignment: ":= <expression>"
  var_exp = T.assignment expression;

  //argument declaration: "id : <type> ;"
  arg_list_helper = argument_decl T.semicolon;

  //inheritance: "inherits from id"
  inherits_from = T.inherits T.from T.identifier;

  //inner class: " { <cr> <class> }"
  inner_class = T.newline+ class;

  